{
  "env": {
    "CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC": "true",
    "CLAUDE_CODE_TMPDIR": "/tmp/claude",
    "IS_DEMO": "true",
    "ENABLE_TOOL_SEARCH": "true"
  },
  "includeCoAuthoredBy": false,
  "sandbox": {
    "enabled": true,
    "excludedCommands": ["git:*", "gh:*"]
  },
  "permissions": {
    "allow": [
      "Bash(gh:*)",
      "Bash(git:*)",
      "Edit(//tmp)",
      "Read",
      "WebFetch",
      "WebSearch"
    ],
    "deny": [],
    "ask": []
  },
  "plansDirectory": "./.claude/plans",
  "language": "Korean",
  "spinnerTipsEnabled": false,
  "terminalProgressBarEnabled": false,
  "statusLine": {
    "type": "command",
    "command": "input=$(cat); cwd=$(echo \"$input\" | jq -r '.workspace.current_dir'); dir=\"${cwd/#$HOME/~}\"; [ ${#dir} -gt 80 ] && dir=\"…/$(basename \"$dir\")\"; git_info=\"\"; if git -C \"$cwd\" rev-parse --git-dir >/dev/null 2>&1; then branch=$(git -C \"$cwd\" -c core.useBuiltinFSMonitor=false -c gc.autodetach=false symbolic-ref --short HEAD 2>/dev/null || git -C \"$cwd\" -c core.useBuiltinFSMonitor=false -c gc.autodetach=false rev-parse --short HEAD 2>/dev/null); [ -n \"$branch\" ] && { [ ${#branch} -gt 32 ] && branch=\"${branch:0:12}…${branch: -12}\"; git_info=\" \\033[0mon \\033[32m${branch}\\033[0m\"; commit_msg=$(git -C \"$cwd\" log -1 --pretty=%s 2>/dev/null); [[ \"$commit_msg\" =~ (^|[^[:alnum:]])(wip|WIP)([^[:alnum:]]|$) ]] && git_info=\"${git_info} \\033[33mwip\\033[0m\"; upstream=$(git -C \"$cwd\" rev-parse --abbrev-ref @{upstream} 2>/dev/null); [ -n \"$upstream\" ] && { ahead=$(git -C \"$cwd\" rev-list --count @{upstream}..HEAD 2>/dev/null || echo 0); behind=$(git -C \"$cwd\" rev-list --count HEAD..@{upstream} 2>/dev/null || echo 0); [ \"$behind\" -gt 0 ] && git_info=\"${git_info} \\033[32m⇣${behind}\\033[0m\"; [ \"$ahead\" -gt 0 ] && { [ \"$behind\" -eq 0 ] && git_info=\"${git_info} \"; git_info=\"${git_info}\\033[32m⇡${ahead}\\033[0m\"; }; }; stashes=$(git -C \"$cwd\" stash list 2>/dev/null | wc -l | tr -d ' '); [ \"$stashes\" -gt 0 ] && git_info=\"${git_info} \\033[32m*${stashes}\\033[0m\"; git_dir=$(git -C \"$cwd\" rev-parse --git-dir 2>/dev/null); action=\"\"; [ -d \"$git_dir/rebase-merge\" ] && action=\"rebase\" || [ -d \"$git_dir/rebase-apply\" ] && action=\"rebase\" || [ -f \"$git_dir/MERGE_HEAD\" ] && action=\"merge\" || [ -f \"$git_dir/CHERRY_PICK_HEAD\" ] && action=\"cherry-pick\" || [ -f \"$git_dir/REVERT_HEAD\" ] && action=\"revert\" || [ -f \"$git_dir/BISECT_LOG\" ] && action=\"bisect\"; [ -n \"$action\" ] && git_info=\"${git_info} \\033[31m${action}\\033[0m\"; status=$(git -C \"$cwd\" -c core.useBuiltinFSMonitor=false -c gc.autodetach=false status --porcelain=v1 2>/dev/null); conflicts=$(echo \"$status\" | grep -c '^UU\\|^AA\\|^DD' || true); staged=$(echo \"$status\" | grep -c '^[MADRC]' || true); unstaged=$(echo \"$status\" | grep -c '^.[MD]' || true); untracked=$(echo \"$status\" | grep -c '^??' || true); [ \"$conflicts\" -gt 0 ] && git_info=\"${git_info} \\033[31m~${conflicts}\\033[0m\"; [ \"$staged\" -gt 0 ] && git_info=\"${git_info} \\033[33m+${staged}\\033[0m\"; [ \"$unstaged\" -gt 0 ] && git_info=\"${git_info} \\033[33m!${unstaged}\\033[0m\"; [ \"$untracked\" -gt 0 ] && git_info=\"${git_info} \\033[34m?${untracked}\\033[0m\"; }; fi; printf \"\\033[34m${dir}\\033[0m${git_info}\""
  }
}
